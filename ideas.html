<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>ckaestne/TypeChef @ GitHub</title>

  <style type="text/css">
    body {
      margin-top: 1.0em;
      font-family: Helvetica, Arial, FreeSans, san-serif;
    }
    #container {
      margin: 0 auto;
      width: 700px;
    }
    h1 { font-size: 3.8em; color: #336600; margin-bottom: 3px; }
    h1 .small { font-size: 0.4em; }
    h1 a { text-decoration: none }
    h2 { font-size: 1.5em; color: #336600; }
    h3 { text-align: center; color: #336600; }
    a { color: #336600; }
    .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
    .download { float: right; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; }
  </style>
  <link href="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.css" type="text/css" rel="stylesheet"/>
  <script src="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.js" type="text/javascript"></script>
</head>

<body onload="prettyPrint()">
  <a href="http://github.com/ckaestne/TypeChef"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>

  <div id="container">

    <h1><a href="http://github.com/ckaestne/TypeChef">TypeChef</a>
      </h1>

    <div class="description">
      Project ideas for Google Summer of Code 2012:
    </div>

    <!-- project 1 -->
    <h2>Transformation of #ifdefs into ifs</h2>
    <p>
    <ul>
    <li><em>Project description:</em>
    Goal of this project is to apply variability-aware model-checking for Linux device drivers (<a href="http://linuxtesting.org/project/ldv/" target="_blank">Linux Driver Verification</a>). In the past model checking for Linux device drivers focused on a particular configuration of the source code, i.e. source code without #ifdefs. In this project we want to apply model-checking for all variants of the source code. Therefore a tool should be developed to automatically transform source code with #ifdefs into source code without #ifdefs, in which the variability is represented using conditional programming of the programming language C. For example, the following #ifdef annotated assignment can be transformed using an if statement. The transformed expression A is a globally visible configuration parameter.

    <table>
        <tr>
        <td>
        <pre class="prettyprint lang-c">
void foo() {
    int a = 0;
    #ifdef A
    a = a + 1;
    #endif
}
        </pre>
        </div>
        </td>

        <td>
        <pre class="prettyprint lang-c">
int A;		
void foo() {
    int a = 0;
    if (A) {
        a = a + 1;
    }
}
        </pre>
        </td>
    </tr>
    </table>

	Although apparently simple in this example, challenges arise with conditional compilation at top level. For example, two alternative definitions of a function must be integrated or resolved with renaming one definition and disambiguating call-site variability. Corresponding analysis builds on top of the existing variability-aware parser and type system.
    </li>

    <li><em>Expected results:</em> A tool should be developed as part of TypeChef that automatically transforms all #ifdefs into ifs. The output source code should compile with a standard C compiler.</li>
    <li><em>Knowledge prerequisite:</em> TypeChef is developed mostly in Scala and applied to C code. Applicants should have a fair understanding of at least one of these languages. Especially prior experience with functional programming and Scala is a plus. </li>
    <li><em>Mentor:</em> J&ouml;rg Liebig (<a href="http://www.infosun.fim.uni-passau.de/cl/staff/liebig/" target="_blank">website</a>)</li>
    </ul>


    <!-- project 2 -->
    <h2>Implemenation of code analyses and application in case studies</h2>
    <ul>
    <li><em>Project description:</em> Many useful tools have been developed to support programmers while implementing new programs. Usually these tools rest on static code analyses, such as dead-code elimination (<a href="http://en.wikipedia.org/wiki/Dead_code_elimination/" target="_blank">link</a>), dead store (<a href="http://en.wikipedia.org/wiki/Dead_store/" target="_blank">link</a>), or unreachable code (<a href="http://en.wikipedia.org/wiki/Unreachable_code/" target="_blank">link</a>). Aim of this project is to reimplement existing code analyses algorithms in the TypeChef. The algorithms have to be adapted to the existence of #ifdefs in the source code, so variable results can occur. For example, in the following code example (left side), the assignment (b = 24;) is dead when A is defined.

    <pre class="prettyprint lang-c">
void foo() {
    int a = 24;
    int b = 25;
    int c;
    c = a &lt;&lt; 2;
    // if A is defined
    // code b = 24;
    // is unreachable
    #ifdef A
    return c;
    #endif
    b = 24;
    return 0;
}
    </pre>
	
	The results of this analysis can be used to find errors in all configurations of a C project and can furthermore improve the precision of TypeChef's type system and linker analysis.
	
    <li><em>Expected results:</em> A set of static code analyis algorithms should be implemented as part of the TypeChef infrastructure. Furthermore, the algorithms should be evaluated in a set of case studies such as the Linux kernel or busybox.</li>
	<li><em>Knowledge prerequisite:</em> 
	As TypeChef is developed in Scala, applicants should have a fair understanding of Scala or at least Java. Prior knowledge of static analysis is a plus.
    <li><em>Mentor:</em> J&ouml;rg Liebig (<a href="http://www.infosun.fim.uni-passau.de/cl/staff/liebig/" target="_blank">website</a>)</li>
    </ul>


    <!-- project 3 -->
    <h2>Implemenation of a variablity-aware refactoring engine</h2>
    <ul>
    <li><p><em>Project description:</em> Current integrated development enviroments (IDE), such as Eclipse or IntelliJ, have a rich toolset to support programming activity. One major part of these toolsets are refactoring engines, that support source code restructurings to improve code quality, while preserving program behavior. Unfortunately, most refactoring engines for C break or are unreliable in the presence of conditional compilation. </p>
	
	<p>As simple example consider a rename refactoring of variables a and b in the following code snippet, that should preserve the behavior of all configurations.
 <pre class="prettyprint lang-c">
#define FOO a
void foo() {
    int a = 0;
    #ifdef A
    a = FOO + 1;
	float b = 1;
	#else
	int b = a * 2;
    #endif
	println(b);
	println(FOO);
}
        </pre>
	
    <li><em>Expected results:</em> A refactoring engine on top of the TypeChef parser that correctly rewrites all configurations without relying on a brute-force strategy.</li>
	<li><em>Knowledge prerequisite:</em> as above.
    <li><em>Mentor:</em> J&ouml;rg Liebig (<a href="http://www.infosun.fim.uni-passau.de/cl/staff/liebig/" target="_blank">website</a>)</li>
    </ul>


    <!-- project 4 -->
    <h2>Reimplementation of the parsing engine using a GLR parser</h2>
    <ul>
    <li><em>Project description:</em> The current parser of the TypeChef is implemented as parser combinator libary (recursive decent, backtracking parser), which allowed easy exploration of concepts (which are now well described and explored) but runs with comparably poor performance on the Java virtual machine. As the parser concept aligns well with the splitting and joining of parse forests in generalized LR parsers (GLR), but considers variability explicitly, we envision a compatible parser based on GLR technology. The Java implementation of a GLR parser in <a href="http://strategoxt.org/Spoofax">Spoofax</a> can serve as a good starting point.</li>
    <li><em>Expected results:</em> A variability-aware parser reusing GLR concepts. Demonstrating that the new parser yields equivalent results at better performance, for example, with a demonstration of parsing the Linux kernel.</li>
	<li><em>Knowledge prerequisite:</em> Knowledge of Java is required. Prior experience with Scala is a plus but not necessary. Some basic knowledge of parser strategies is helpful.
    <li><em>Mentor:</em> Christian K&auml;stner (<a href="http://www.uni-marburg.de/fb12/ps/team/kaestner/" target="_blank">website</a>)</li>
    </ul>


  </div>
</body>
</html>
