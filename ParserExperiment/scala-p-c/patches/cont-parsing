Index: Corso/Parsers.scala
===================================================================
--- Corso.orig/Parsers.scala
+++ Corso/Parsers.scala
@@ -10,6 +10,7 @@
 package scala.util.parsing.combinator
 
 import scala.util.parsing.input._
+import scala.util.continuations._
 import scala.collection.mutable.ListBuffer
 import scala.annotation.tailrec
 
@@ -207,6 +208,59 @@ trait Parsers {
     def append[U >: T](p: => Parser[U]): Parser[U] 
       = Parser{ in => this(in) append p(in)}
 
+    def baseParserSeq [U](p: => Parser[U]): Parser[~[T, U]] = (for(a <- this; b <- p) yield new ~(a,b)).named("~")
+
+    sealed abstract class StateFork {
+    }
+    case class ParserStateFork(cont: Parser[T]) extends StateFork
+    case class StacksStateFork(cont: Parser[T], states: List[_]) extends StateFork
+
+    var contStack = new ArrayStack()
+    def pushNext(next: => Parser[T]) {
+      contStack.push(next)
+    }
+    //Please, if you want nice backtracking behavior, pass an already composed
+    //alternative parser to ~ and invoke; OK, as you would do normally, but the
+    //impact is amplified.
+    def invoke(next: => Parser[T]): Parser[T] = {
+      //accept("#ifdef") /*Or #if*/ baseParserSeq reset next
+      accept("#ifdef") /*Or #if*/ <~ {push next; reset next} /*do the same handling as below
+      for #if: push next somewhere. */
+    }
+    //(opt(accept("#if")) <~ reset p)
+
+    /*commit? OK, we don't want to
+    backtrack after seeing "#ifdef, but... */
+    //(opt(accept("#if")) <~ commit(reset p))
+
+    /*match {
+        case (~(a, b)) => return b
+      }
+      (
+        accept("#ifdef") ~ commit(reset p) |
+      ) match {
+        case (~(a, b)) => return b
+      }*/
+    //def ~ [U](p: => Parser[U]): Parser[~[T, U]] = baseParserSeq(this, invoke(p))
+    def ~ [U](next: => Parser[U]): Parser[~[T, U]] = {
+      this baseParserSeq (
+        accept("#ifdef") ~ reset next | /* Also push next somewhere, so as to
+        reinvoke it and to check if we re-share it.*/
+        (accept("#else")|accept("#elif")) ~ shift k /* Fetch firstNext from top
+        of the stack, store (k, next) in the list of suspended
+        closures associated with firstNext,
+        reinvoke firstNext under reset (maybe the original one is enough, maybe
+        not).*/
+        commit(reset next) |
+        accept("#endif") ~ commit(reset next) /* Do the same as in #else, then
+        pop the context stack and merge back the suspended works which have the
+        same next component; then, for each entry in the merged list, invoke
+        next, pass the result to all continuations, and finally merge them in an
+        alternative node. Fuuuh! */
+      ) match {
+        case (~(a, b)) => return b
+      }
+    }
                                       
     // the operator formerly known as +++, ++, &, but now, behold the venerable ~
     // it's short, light (looks like whitespace), has few overloaded meaning (thanks to the recent change from ~ to unary_~)
